buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath 'com.guardsquare:proguard-gradle:7.1.0'
	}
}

plugins {
	id 'java'
	id 'maven-publish'

}

group 'com.zjm.api'
version '0.0.1'

repositories {
	mavenCentral()
	maven {
		allowInsecureProtocol = true
		url = 'http://maven.aliyun.com/repository/public'
	}

}

dependencies {
	implementation 'org.projectlombok:lombok:1.18.24'
	annotationProcessor group: 'org.projectlombok', name: 'lombok', version: "1.18.24"

	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
	implementation 'com.alibaba:fastjson:2.0.9'
	implementation 'org.bouncycastle:bcprov-jdk15on:1.69'
	implementation 'com.github.rholder:guava-retrying:2.0.0'
	implementation 'org.springframework.boot:spring-boot-starter-web:2.6.6'
	testImplementation 'org.springframework.boot:spring-boot-starter-test:2.6.6'
	implementation 'org.apache.commons:commons-lang3:3.5'
	implementation 'commons-io:commons-io:2.2'
	implementation 'commons-collections:commons-collections:3.2.2'
	implementation 'org.apache.httpcomponents:httpclient:4.5.14'

//    implementation  files('lib/license-sdk-1.0.1.jar')
}

test {
	useJUnitPlatform()
}

tasks.withType(JavaCompile) {
	options.encoding = "UTF-8"
}

task('createObfuscated', type: proguard.gradle.ProGuardTask, dependsOn: jar) {
	// You should probably import a more compact ProGuard-style configuration
	// file for all static settings, but we're specifying them all here, for
	// the sake of the example.
	//configuration 'configuration.pro'

	verbose

//    dontwarn()
	// Specify the input jars, output jars, and library jars.
	// In this case, the input jar is the program library that we want to process.

	injars "build/libs/${rootProject.name}-${version}.jar"
	outjars "build/obf/${rootProject.name}-${version}.jar"
	libraryjars(configurations.runtimeClasspath)

	// Automatically handle the Java version of this build.
	if (System.getProperty('java.version').startsWith('1.')) {
		// Before Java 9, the runtime classes were packaged in a single jar file.
		libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
	} else {
		// As of Java 9, the runtime classes are packaged in modular jmod files.
		libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
		//libraryjars "${System.getProperty('java.home')}/jmods/....."
	}

	// Save the obfuscation mapping to a file, so we can de-obfuscate any stack
	// traces later on. Keep a fixed source file attribute and all line number
	// tables to get line numbers in the stack traces.
	// You can comment this out if you're not interested in stack traces.

	printmapping 'out.map'
	keepparameternames
	renamesourcefileattribute 'SourceFile'
	keepattributes 'Signature,Exceptions,InnerClasses,PermittedSubclasses,EnclosingMethod,Deprecated,SourceFile,LineNumberTable'

	keepnames("class com.cestc.di.license.annotation.ConditionalOnSdkPathCondition")

	printseeds("out.seeds")
	// Preserve all annotations.

	keepattributes '*Annotation*'

	// Preserve all public classes, and their public and protected fields and
	// methods.

	keep 'public class * { \
        public protected *; \
    }'

	keep 'class org.springframework.*'

	// Preserve all .class method names.

	keepclassmembernames 'class * { \
        java.lang.Class class$(java.lang.String); \
        java.lang.Class class$(java.lang.String, boolean); \
    }'

	// Preserve all native method names and the names of their classes.

	keepclasseswithmembernames includedescriptorclasses: true, 'class * { \
        native <methods>; \
    }'
//    keep 'public class com.cestc.di.license.ConditionalOnSdkPathConfig implements org.springframework.context.annotation.Condition '
	keepnames 'class * implements *'
	// Preserve the special static methods that are required in all enumeration
	// classes.

	keepclassmembers allowoptimization: true, 'enum * { \
        public static **[] values(); \
        public static ** valueOf(java.lang.String); \
    }'

	// Explicitly preserve all serialization members. The Serializable interface
	// is only a marker interface, so it wouldn't save them.
	// You can comment this out if your library doesn't use serialization.
	// If your code contains serializable classes that have to be backward
	// compatible, please refer to the manual.

	keepclassmembers 'class * implements java.io.Serializable { \
        static final long serialVersionUID; \
        static final java.io.ObjectStreamField[] serialPersistentFields; \
        private void writeObject(java.io.ObjectOutputStream); \
        private void readObject(java.io.ObjectInputStream); \
        java.lang.Object writeReplace(); \
        java.lang.Object readResolve(); \
    }'

	// Your library may contain more items that need to be preserved;
	// typically classes that are dynamically created using Class.forName:

	// keep 'public class com.example.MyClass'
	// keep 'public interface com.example.MyInterface'
//     keep 'public class * implements Condition {'
}

task copyObfuscated(type: Copy, dependsOn: createObfuscated) {
	from "${buildDir}/obf"
	into "${buildDir}/libs"
	include '*.jar'
}

task deleteObfuscated(type: Delete, dependsOn: copyObfuscated) {
	delete "${buildDir}/obf"
}
publish.dependsOn deleteObfuscated


